/* tslint:disable */
/* eslint-disable */
/**
 * user
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';

// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { Credentials } from '../../src/model';
// @ts-ignore
import { CredentialsRemove } from '../../src/model';
// @ts-ignore
import { EmailSigninInput } from '../../src/model';
// @ts-ignore
import { EmailSignupInput } from '../../src/model';
// @ts-ignore
import { ErrorSchema } from '../../src/model';
import { Configuration } from '../configuration';
/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * OAuth Token From Code  public: false cache: no
     * @summary OAuth Token From Code
     * @param {string} [w] World ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oauthToken: async (w?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/auth/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      if (w !== undefined) {
        localVarQueryParameter['w'] = w;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 토큰 리프래시  public: false cache: no
     * @summary 토큰 리프래시
     * @param {string} body
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken: async (body: string, w?: string, p?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('refreshToken', 'body', body);
      const localVarPath = `/v1/auth/refresh`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (w !== undefined) {
        localVarQueryParameter['w'] = w;
      }

      if (p !== undefined) {
        localVarQueryParameter['p'] = p;
      }

      localVarHeaderParameter['Content-Type'] = 'text/plain';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 애플 로그인  public: false cache: no
     * @summary 애플 로그인
     * @param {string} code Apple Response Code
     * @param {string} idToken Apple JWT
     * @param {string} state Apple\&#39;s Response State
     * @param {string} user Apple\&#39;s Response User
     * @param {string} source Source of the key: web, ios, android
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signinApple: async (code: string, idToken: string, state: string, user: string, source: string, w?: string, p?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'code' is not null or undefined
      assertParamExists('signinApple', 'code', code);
      // verify required parameter 'idToken' is not null or undefined
      assertParamExists('signinApple', 'idToken', idToken);
      // verify required parameter 'state' is not null or undefined
      assertParamExists('signinApple', 'state', state);
      // verify required parameter 'user' is not null or undefined
      assertParamExists('signinApple', 'user', user);
      // verify required parameter 'source' is not null or undefined
      assertParamExists('signinApple', 'source', source);
      const localVarPath = `/v1/auth/signin/apple`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      if (code !== undefined) {
        localVarQueryParameter['code'] = code;
      }

      if (idToken !== undefined) {
        localVarQueryParameter['id_token'] = idToken;
      }

      if (state !== undefined) {
        localVarQueryParameter['state'] = state;
      }

      if (user !== undefined) {
        localVarQueryParameter['user'] = user;
      }

      if (source !== undefined) {
        localVarQueryParameter['source'] = source;
      }

      if (w !== undefined) {
        localVarQueryParameter['w'] = w;
      }

      if (p !== undefined) {
        localVarQueryParameter['p'] = p;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 애플 로그인 URL 진행  public: false cache: no
     * @summary 애플 로그인 URL 진행
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signinAppleAuthorize: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/auth/signin/apple/authorize`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 이메일 로그인  public: false cache: no
     * @summary 이메일 로그인
     * @param {EmailSigninInput} emailSigninInput
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signinEmail: async (emailSigninInput: EmailSigninInput, w?: string, p?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'emailSigninInput' is not null or undefined
      assertParamExists('signinEmail', 'emailSigninInput', emailSigninInput);
      const localVarPath = `/v1/auth/signin/email`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      if (w !== undefined) {
        localVarQueryParameter['w'] = w;
      }

      if (p !== undefined) {
        localVarQueryParameter['p'] = p;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(emailSigninInput, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 구글 로그인  public: false cache: no
     * @summary 구글 로그인
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signinGoogle: async (w?: string, p?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/auth/signin/google`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      if (w !== undefined) {
        localVarQueryParameter['w'] = w;
      }

      if (p !== undefined) {
        localVarQueryParameter['p'] = p;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 구글 로그인 URL 진행  public: false cache: no
     * @summary 구글 로그인 URL 진행
     * @param {string} apikey API Key
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signinGoogleAuthorize: async (apikey: string, w?: string, p?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'apikey' is not null or undefined
      assertParamExists('signinGoogleAuthorize', 'apikey', apikey);
      const localVarPath = `/v1/auth/signin/google/authorize`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (w !== undefined) {
        localVarQueryParameter['w'] = w;
      }

      if (p !== undefined) {
        localVarQueryParameter['p'] = p;
      }

      if (apikey !== undefined) {
        localVarQueryParameter['apikey'] = apikey;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 카카오 로그인  public: false cache: no
     * @summary 카카오 로그인
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signinKakao: async (w?: string, p?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/auth/signin/kakao`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      if (w !== undefined) {
        localVarQueryParameter['w'] = w;
      }

      if (p !== undefined) {
        localVarQueryParameter['p'] = p;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 카카오 로그인 Authorize  public: false cache: no
     * @summary 카카오 로그인 Authorize
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signinKakaoAuthorize: async (w?: string, p?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/auth/signin/kakao/authorize`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      if (w !== undefined) {
        localVarQueryParameter['w'] = w;
      }

      if (p !== undefined) {
        localVarQueryParameter['p'] = p;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 트위터 로그인  public: false cache: no
     * @summary 트위터 로그인
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signinTw: async (w?: string, p?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/auth/signin/twitter`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      if (w !== undefined) {
        localVarQueryParameter['w'] = w;
      }

      if (p !== undefined) {
        localVarQueryParameter['p'] = p;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 로그아웃  public: false cache: no
     * @summary 로그아웃
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/auth/signout`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      // authentication bearer required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * 이메일 가입  public: false cache: no
     * @summary 이메일 가입
     * @param {EmailSignupInput} emailSignupInput
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signupEmail: async (emailSignupInput: EmailSignupInput, w?: string, p?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'emailSignupInput' is not null or undefined
      assertParamExists('signupEmail', 'emailSignupInput', emailSignupInput);
      const localVarPath = `/v1/auth/signup/email`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      if (w !== undefined) {
        localVarQueryParameter['w'] = w;
      }

      if (p !== undefined) {
        localVarQueryParameter['p'] = p;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(emailSignupInput, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Redirect URI Verification  public: false cache: no
     * @summary Redirect URI Verification
     * @param {string} redirectUri Redirect URI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyRedirectUri: async (redirectUri: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'redirectUri' is not null or undefined
      assertParamExists('verifyRedirectUri', 'redirectUri', redirectUri);
      const localVarPath = `/v1/auth/verify_redirect_uri`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apikey required
      await setApiKeyToObject(localVarHeaderParameter, 'X-API-KEY', configuration);

      if (redirectUri !== undefined) {
        localVarQueryParameter['redirect_uri'] = redirectUri;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration);
  return {
    /**
     * OAuth Token From Code  public: false cache: no
     * @summary OAuth Token From Code
     * @param {string} [w] World ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async oauthToken(w?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credentials>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.oauthToken(w, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 토큰 리프래시  public: false cache: no
     * @summary 토큰 리프래시
     * @param {string} body
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshToken(body: string, w?: string, p?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credentials>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(body, w, p, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 애플 로그인  public: false cache: no
     * @summary 애플 로그인
     * @param {string} code Apple Response Code
     * @param {string} idToken Apple JWT
     * @param {string} state Apple\&#39;s Response State
     * @param {string} user Apple\&#39;s Response User
     * @param {string} source Source of the key: web, ios, android
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signinApple(
      code: string,
      idToken: string,
      state: string,
      user: string,
      source: string,
      w?: string,
      p?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credentials>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signinApple(code, idToken, state, user, source, w, p, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 애플 로그인 URL 진행  public: false cache: no
     * @summary 애플 로그인 URL 진행
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signinAppleAuthorize(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signinAppleAuthorize(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 이메일 로그인  public: false cache: no
     * @summary 이메일 로그인
     * @param {EmailSigninInput} emailSigninInput
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signinEmail(emailSigninInput: EmailSigninInput, w?: string, p?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credentials>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signinEmail(emailSigninInput, w, p, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 구글 로그인  public: false cache: no
     * @summary 구글 로그인
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signinGoogle(w?: string, p?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credentials>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signinGoogle(w, p, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 구글 로그인 URL 진행  public: false cache: no
     * @summary 구글 로그인 URL 진행
     * @param {string} apikey API Key
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signinGoogleAuthorize(apikey: string, w?: string, p?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signinGoogleAuthorize(apikey, w, p, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 카카오 로그인  public: false cache: no
     * @summary 카카오 로그인
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signinKakao(w?: string, p?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credentials>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signinKakao(w, p, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 카카오 로그인 Authorize  public: false cache: no
     * @summary 카카오 로그인 Authorize
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signinKakaoAuthorize(w?: string, p?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signinKakaoAuthorize(w, p, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 트위터 로그인  public: false cache: no
     * @summary 트위터 로그인
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signinTw(w?: string, p?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credentials>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signinTw(w, p, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 로그아웃  public: false cache: no
     * @summary 로그아웃
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CredentialsRemove>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signout(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * 이메일 가입  public: false cache: no
     * @summary 이메일 가입
     * @param {EmailSignupInput} emailSignupInput
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signupEmail(emailSignupInput: EmailSignupInput, w?: string, p?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Credentials>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signupEmail(emailSignupInput, w, p, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Redirect URI Verification  public: false cache: no
     * @summary Redirect URI Verification
     * @param {string} redirectUri Redirect URI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifyRedirectUri(redirectUri: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.verifyRedirectUri(redirectUri, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = AuthApiFp(configuration);
  return {
    /**
     * OAuth Token From Code  public: false cache: no
     * @summary OAuth Token From Code
     * @param {string} [w] World ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oauthToken(w?: string, options?: any): AxiosPromise<Credentials> {
      return localVarFp.oauthToken(w, options).then(request => request(axios, basePath));
    },
    /**
     * 토큰 리프래시  public: false cache: no
     * @summary 토큰 리프래시
     * @param {string} body
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken(body: string, w?: string, p?: string, options?: any): AxiosPromise<Credentials> {
      return localVarFp.refreshToken(body, w, p, options).then(request => request(axios, basePath));
    },
    /**
     * 애플 로그인  public: false cache: no
     * @summary 애플 로그인
     * @param {string} code Apple Response Code
     * @param {string} idToken Apple JWT
     * @param {string} state Apple\&#39;s Response State
     * @param {string} user Apple\&#39;s Response User
     * @param {string} source Source of the key: web, ios, android
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signinApple(code: string, idToken: string, state: string, user: string, source: string, w?: string, p?: string, options?: any): AxiosPromise<Credentials> {
      return localVarFp.signinApple(code, idToken, state, user, source, w, p, options).then(request => request(axios, basePath));
    },
    /**
     * 애플 로그인 URL 진행  public: false cache: no
     * @summary 애플 로그인 URL 진행
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signinAppleAuthorize(options?: any): AxiosPromise<void> {
      return localVarFp.signinAppleAuthorize(options).then(request => request(axios, basePath));
    },
    /**
     * 이메일 로그인  public: false cache: no
     * @summary 이메일 로그인
     * @param {EmailSigninInput} emailSigninInput
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signinEmail(emailSigninInput: EmailSigninInput, w?: string, p?: string, options?: any): AxiosPromise<Credentials> {
      return localVarFp.signinEmail(emailSigninInput, w, p, options).then(request => request(axios, basePath));
    },
    /**
     * 구글 로그인  public: false cache: no
     * @summary 구글 로그인
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signinGoogle(w?: string, p?: string, options?: any): AxiosPromise<Credentials> {
      return localVarFp.signinGoogle(w, p, options).then(request => request(axios, basePath));
    },
    /**
     * 구글 로그인 URL 진행  public: false cache: no
     * @summary 구글 로그인 URL 진행
     * @param {string} apikey API Key
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signinGoogleAuthorize(apikey: string, w?: string, p?: string, options?: any): AxiosPromise<void> {
      return localVarFp.signinGoogleAuthorize(apikey, w, p, options).then(request => request(axios, basePath));
    },
    /**
     * 카카오 로그인  public: false cache: no
     * @summary 카카오 로그인
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signinKakao(w?: string, p?: string, options?: any): AxiosPromise<Credentials> {
      return localVarFp.signinKakao(w, p, options).then(request => request(axios, basePath));
    },
    /**
     * 카카오 로그인 Authorize  public: false cache: no
     * @summary 카카오 로그인 Authorize
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signinKakaoAuthorize(w?: string, p?: string, options?: any): AxiosPromise<void> {
      return localVarFp.signinKakaoAuthorize(w, p, options).then(request => request(axios, basePath));
    },
    /**
     * 트위터 로그인  public: false cache: no
     * @summary 트위터 로그인
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signinTw(w?: string, p?: string, options?: any): AxiosPromise<Credentials> {
      return localVarFp.signinTw(w, p, options).then(request => request(axios, basePath));
    },
    /**
     * 로그아웃  public: false cache: no
     * @summary 로그아웃
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signout(options?: any): AxiosPromise<CredentialsRemove> {
      return localVarFp.signout(options).then(request => request(axios, basePath));
    },
    /**
     * 이메일 가입  public: false cache: no
     * @summary 이메일 가입
     * @param {EmailSignupInput} emailSignupInput
     * @param {string} [w] World ID
     * @param {string} [p] Profile ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signupEmail(emailSignupInput: EmailSignupInput, w?: string, p?: string, options?: any): AxiosPromise<Credentials> {
      return localVarFp.signupEmail(emailSignupInput, w, p, options).then(request => request(axios, basePath));
    },
    /**
     * Redirect URI Verification  public: false cache: no
     * @summary Redirect URI Verification
     * @param {string} redirectUri Redirect URI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyRedirectUri(redirectUri: string, options?: any): AxiosPromise<void> {
      return localVarFp.verifyRedirectUri(redirectUri, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   * OAuth Token From Code  public: false cache: no
   * @summary OAuth Token From Code
   * @param {string} [w] World ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public oauthToken(w?: string, options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .oauthToken(w, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 토큰 리프래시  public: false cache: no
   * @summary 토큰 리프래시
   * @param {string} body
   * @param {string} [w] World ID
   * @param {string} [p] Profile ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public refreshToken(body: string, w?: string, p?: string, options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .refreshToken(body, w, p, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 애플 로그인  public: false cache: no
   * @summary 애플 로그인
   * @param {string} code Apple Response Code
   * @param {string} idToken Apple JWT
   * @param {string} state Apple\&#39;s Response State
   * @param {string} user Apple\&#39;s Response User
   * @param {string} source Source of the key: web, ios, android
   * @param {string} [w] World ID
   * @param {string} [p] Profile ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public signinApple(code: string, idToken: string, state: string, user: string, source: string, w?: string, p?: string, options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .signinApple(code, idToken, state, user, source, w, p, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 애플 로그인 URL 진행  public: false cache: no
   * @summary 애플 로그인 URL 진행
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public signinAppleAuthorize(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .signinAppleAuthorize(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 이메일 로그인  public: false cache: no
   * @summary 이메일 로그인
   * @param {EmailSigninInput} emailSigninInput
   * @param {string} [w] World ID
   * @param {string} [p] Profile ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public signinEmail(emailSigninInput: EmailSigninInput, w?: string, p?: string, options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .signinEmail(emailSigninInput, w, p, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 구글 로그인  public: false cache: no
   * @summary 구글 로그인
   * @param {string} [w] World ID
   * @param {string} [p] Profile ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public signinGoogle(w?: string, p?: string, options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .signinGoogle(w, p, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 구글 로그인 URL 진행  public: false cache: no
   * @summary 구글 로그인 URL 진행
   * @param {string} apikey API Key
   * @param {string} [w] World ID
   * @param {string} [p] Profile ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public signinGoogleAuthorize(apikey: string, w?: string, p?: string, options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .signinGoogleAuthorize(apikey, w, p, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 카카오 로그인  public: false cache: no
   * @summary 카카오 로그인
   * @param {string} [w] World ID
   * @param {string} [p] Profile ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public signinKakao(w?: string, p?: string, options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .signinKakao(w, p, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 카카오 로그인 Authorize  public: false cache: no
   * @summary 카카오 로그인 Authorize
   * @param {string} [w] World ID
   * @param {string} [p] Profile ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public signinKakaoAuthorize(w?: string, p?: string, options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .signinKakaoAuthorize(w, p, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 트위터 로그인  public: false cache: no
   * @summary 트위터 로그인
   * @param {string} [w] World ID
   * @param {string} [p] Profile ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public signinTw(w?: string, p?: string, options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .signinTw(w, p, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 로그아웃  public: false cache: no
   * @summary 로그아웃
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public signout(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .signout(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * 이메일 가입  public: false cache: no
   * @summary 이메일 가입
   * @param {EmailSignupInput} emailSignupInput
   * @param {string} [w] World ID
   * @param {string} [p] Profile ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public signupEmail(emailSignupInput: EmailSignupInput, w?: string, p?: string, options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .signupEmail(emailSignupInput, w, p, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Redirect URI Verification  public: false cache: no
   * @summary Redirect URI Verification
   * @param {string} redirectUri Redirect URI
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public verifyRedirectUri(redirectUri: string, options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .verifyRedirectUri(redirectUri, options)
      .then(request => request(this.axios, this.basePath));
  }
}
